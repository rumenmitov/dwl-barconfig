From e733fda4e498c998a104d0d5bb42b9c7373f2c9d Mon Sep 17 00:00:00 2001
From: Rumen <rumenmitov@protonmail.com>
Date: Fri, 24 Oct 2025 09:33:24 +0200
Subject: [PATCH] Barconfig: Configure the dwl bar!

NOTE: This is a port of the original barconfig patch for dwm!

This patch provides configuration for the dwl bar via the variable
`barlayout`. This determines which of the elements listed below to
display on the bar and in which order:

- 't' -> the tags
- 'l' -> the current layout symbol
- 'n' -> the window name
- 's' -> the status message
- '|' -> elements on the right of this separator will be displayed from
         the right
---
 config.def.h |   1 +
 dwl.c        | 134 +++++++++++++++++++++++++++++++++++----------------
 2 files changed, 93 insertions(+), 42 deletions(-)

diff --git a/config.def.h b/config.def.h
index 1b7472d..c7a33d6 100644
--- a/config.def.h
+++ b/config.def.h
@@ -9,6 +9,7 @@ static const int bypass_surface_visibility = 0;  /* 1 means idle inhibitors will
 static const unsigned int borderpx         = 1;  /* border pixel of windows */
 static const int showbar                   = 1; /* 0 means no bar */
 static const int topbar                    = 1; /* 0 means bottom bar */
+static const char *barlayout               = "tln|s";
 static const char *fonts[]                 = {"monospace:size=10"};
 static const float rootcolor[]             = COLOR(0x000000ff);
 /* This conforms to the xdg-protocol. Set the alpha to zero to restore the old behavior */
diff --git a/dwl.c b/dwl.c
index bf340d8..f0d72cf 100644
--- a/dwl.c
+++ b/dwl.c
@@ -1569,10 +1569,10 @@ dirtomon(enum wlr_direction dir)
 void
 drawbar(Monitor *m)
 {
-	int x, w, tw = 0;
+	int x = 0, w, tw = 0, moveright = 0;
 	int boxs = m->drw->font->height / 9;
 	int boxw = m->drw->font->height / 6 + 2;
-	uint32_t i, occ = 0, urg = 0;
+	uint32_t i, j, occ = 0, urg = 0;
 	Client *c;
 	Buffer *buf;
 
@@ -1581,48 +1581,99 @@ drawbar(Monitor *m)
 	if (!(buf = bufmon(m)))
 		return;
 
-	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		drwl_setscheme(m->drw, colors[SchemeNorm]);
-		tw = TEXTW(m, stext) - m->lrpad + 2; /* 2px right padding */
-		drwl_text(m->drw, m->b.width - tw, 0, tw, m->b.height, 0, stext, 0);
-	}
+	if (barlayout[0] == '\0')
+		barlayout = "tln|s";
+
+	drwl_text(m->drw, 0, 0, m->w.width, m->b.height, 0, "", 0); /* draw background */
+
+	for (i = 0; i < strlen(barlayout); i++) {
+		switch (barlayout[i]) {
+			case 'l':
+				w = TEXTW(m, m->ltsymbol);
+				drwl_setscheme(m->drw, colors[SchemeNorm]);
+				if (moveright) {
+					x -= w;
+					drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, m->ltsymbol, 0);
+				} else
+					x = drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, m->ltsymbol, 0);
+				break;
 
-	wl_list_for_each(c, &clients, link) {
-		if (c->mon != m)
-			continue;
-		occ |= c->tags;
-		if (c->isurgent)
-			urg |= c->tags;
-	}
-	x = 0;
-	c = focustop(m);
-	for (i = 0; i < LENGTH(tags); i++) {
-		w = TEXTW(m, tags[i]);
-		drwl_setscheme(m->drw, colors[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
-		drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, tags[i], urg & 1 << i);
-		if (occ & 1 << i)
-			drwl_rect(m->drw, x + boxs, boxs, boxw, boxw,
-				m == selmon && c && c->tags & 1 << i,
-				urg & 1 << i);
-		x += w;
-	}
-	w = TEXTW(m, m->ltsymbol);
-	drwl_setscheme(m->drw, colors[SchemeNorm]);
-	x = drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, m->ltsymbol, 0);
-
-	if ((w = m->b.width - tw - x) > m->b.height) {
-		if (c) {
-			drwl_setscheme(m->drw, colors[m == selmon ? SchemeSel : SchemeNorm]);
-			drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, client_get_title(c), 0);
-			if (c && c->isfloating)
-				drwl_rect(m->drw, x + boxs, boxs, boxw, boxw, 0, 0);
-		} else {
-			drwl_setscheme(m->drw, colors[SchemeNorm]);
-			drwl_rect(m->drw, x, 0, w, m->b.height, 1, 1);
-		}
-	}
+			case 'n':
+        c = focustop(m);
+        
+        if (c) {
+          tw = TEXTW(m, client_get_title(c));
+          if (moveright)
+            x -= tw;
+
+          drwl_setscheme(m->drw, colors[m == selmon ? SchemeSel : SchemeNorm]);
+          drwl_text(m->drw, x, 0, moveright ? tw : m->w.width, m->b.height, m->lrpad / 2, client_get_title(c), 0);
+
+          if (c && c->isfloating)
+            drwl_rect(m->drw, x + boxs, boxs, boxw, boxw, 0, 0);
+
+        } else {
+          drwl_setscheme(m->drw, colors[SchemeNorm]);
+          drwl_rect(m->drw, x, 0, tw, m->b.height, 1, 1);
+        }
+
+        if (!moveright)
+          x += tw;
+				break;
+
+			case 's':
+				if (m == selmon) { /* status is only drawn on selected monitor */
+					drwl_setscheme(m->drw, colors[SchemeNorm]);
+					tw = TEXTW(m, stext) - m->lrpad + 2; /* 2px right padding */
+					if (moveright) {
+						x -= tw;
+						drwl_text(m->drw, x, 0, tw, m->b.height, 0, stext, 0);
+					} else
+						x = drwl_text(m->drw, x, 0, tw, m->b.height, 0, stext, 0);
+				}
+				break;
+
+			case 't':
+        wl_list_for_each(c, &clients, link)  {
+          if (c->mon != m)
+            continue;
+					occ |= c->tags;
+					if (c->isurgent)
+						urg |= c->tags;
+				}
+
+       c = focustop(m); 
+
+				/* tags */
+				if (moveright) {
+					tw = 0;
+					for (j = 0; j < LENGTH(tags); j++) {
+						tw += TEXTW(m, tags[j]);
+					}
+					x -= tw;
+				}
+				for (j = 0; j < LENGTH(tags); j++) {
+					w = TEXTW(m, tags[j]);
+					drwl_setscheme(m->drw, colors[m->tagset[m->seltags] & 1 << j ? SchemeSel : SchemeNorm]);
+					drwl_text(m->drw, x, 0, w, m->b.height, m->lrpad / 2, tags[j], urg & 1 << j);
+					if (occ & 1 << j)
+						drwl_rect(m->drw, x + boxs, boxs, boxw, boxw,
+							m == selmon && c && c->tags & 1 << j,
+							urg & 1 << i);
+					x += w;
+				}
+				if (moveright)
+					x -= tw;
+				break;
+
+			case '|':
+				moveright = 1;
+				x = m->w.width;
+				break;
+    }
+  }
 
+  
 	wlr_scene_buffer_set_dest_size(m->scene_buffer,
 		m->b.real_width, m->b.real_height);
 	wlr_scene_node_set_position(&m->scene_buffer->node, m->m.x,
-- 
2.51.1

